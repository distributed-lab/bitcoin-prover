{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":5093116407992818901,"abi":{"parameters":[],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7Z3rjtw4koXfxb/9g5dgBDmvshgM+uIZGDDsRl8WWDT87qvyODPLlhRqhdjKE5nEAouqaZ3KoyAzGaQ+n/zzzc/vfvzjP/96//Hfn35784//+fPNh08//fD7+08fp9/+fBO+/E+//fLDx5fffvv9h19/f/OPJJHfvnn38eeXH7N8fvvm3+8/vHvzD46f384vzilfLs4c9ItjjZeLY831djEtXJxTKV8vzqnK64v/+fZNdOs8uXWe3Tont86LW+fs1rm4dV7dOm9+VyLHi6jfVTT6XUaj33U0+l1Io9+VNPpdSqPftTT6XUyj39U0+V1Nk+M9qd/VNPldTZPf1TQhr6Yl1/b14kKx6RdPfznS9U/HEr6/U+TFt++dIq/Vfe8UeWnve6fInUDXO83IjUPfO0XuM/reKXJbsvNOE93+dBLSL+cW4terucXbLca6cPH0py9FrInT64tfaojcH3mpIY0aHq7hA3WMd6vhA/Wid6vhA3W5d6vhA/XPd6vhA3Xm96ohPVDPf7caPtBu4m41HPuU4zUc+5TjNaRRw8M1HPuU4zUc+5TjNRz7lOM1HPuU4zUc+5TDNSxjn3K8hmOfcryGY59yvIZjn3K8hjRqeLiGY59yvIZjn3K8hmOfcryGY59yvIZjn3K4hjz2KcdrOPYpx2s49inHazj2KcdrSKOGh2s49inHazj2KcdrOPYpx2s49inHazj2KYdrKGOfcryGY59yvIZjn3K8hmOfcryGNGp4uIZjn3K8hmOfcryGY59yvIZjn3K8hmOfcriGtcc+JdRbDWPHGmamSw0zt2+K8mI9+rWe/FrPfq2TX+vFr3X2a138Wq9+rTe31hv0alpvcVktJv3iKjlcugYps/uEXno73if0Or3rPgvL5T7Lt1lpCzaIrrN8+pnL92WB7gHuVxZ6kncFdDPS8T6hO5f7TXPoruh+ZYHuuDq+K6Dbs373GcPjNHMU0uVGKcfZjT5JNxfD47RzGzc6GrSlj+gYaNRlsS5P0tHF8Dgt3caNjiZteaY/TpfWty7P0tXFJzmii/Fxujq9fY3P0tXFx+nqNm6Uxof00od0fJw2rW9dnqWri4/T1W3c6GjTlmf647RpXeuSnqWrS89yVpcep6vT29f0LF1dl+8Sc3Gjo01b/pAez1OX6/IsXV16kkekMY02bXGm58dp0/rW5Vm6uvwsZ3X5cbo6vX3t8sVjLkb0WZ6R5tGmLX9Ij0eqy3V5lq4uP8szUhpt2uJMp8dp0/rW5Vm6OnqWs7ouX9PkoX2lZ+nq6FmekdJo05Y/pMcj1eW6PEtXV57lGWkZbdriTC/jX7Mu1+VZurouX2rj4kYfp6vT29fyLF1deZZnpGW0acsf0uOR6mJd+Fm6On6WZ6Q82rTlmT7+UetyXehZ3hjPclbHj9PV6e0rP0tXx8/yjJRHm7b4IS3jkepyXZ6lq5NneUYqo01bnuk06rJYl2fp6uRZzurkcbo6vX0V5K5usn4JiacgQb+4Rbp4bilspdUHkktZpp9bmNUFuQm8Y12gw/bvWRfkJvCedUHuGe9ZF+QW8551oVGXxbogt5j3rAtyR1pSuOwySuI2847cZG55R+4bt7wj93Yb3qG/nmHLO3KPtOUduY/Z8o7ca2x5J8fekdfsLe+O11XodP+S46VXKll4o/2RxBcf06l02uyWEsdrt5Ta7LQHOuD/vpWB7gnuWJkE/R0CZ1ZGZpWB7mf+1srou7IE/S0F960MdC9218rQqMxKZaD7yLtWBrpL3VeZ3ORaGeKNp3oxcrg+ko5MaVaZB+qBd1ZGcrlWRnhemQfqgTtX5oF64L6Vgf7GhftW5oF64M6VeaAeuHNlHqgH7lwZGpVZqcwD9cAs1z8tEvLsVh+oqd261QfqUmu+3WotZXar2G1nvewmCsWtXVmNka5/OpbZrgz6Gx523mqi259OQvrl3MJlxnCLt1uMdeHi6U9fqljTqw+86eKXIkJ/HYSbImJ3p06KiN3IOikids/rpIg0ini8iNidtJMiYvfoToqI3f07KeID7SvuV8SxYzleROhvRnFTxLFj6VDEsWPpUMSxY+lQRBpFPF7EsWPpUMSxY+lQxLFj6VDEsWPpUMSxYzleROgvCXJTxLFj6VDEsWPpUMSxY+lQRBpFPF7EsWPpUMSxY+lQxLFj6VDEsWPpUMSxYzleROgvwHJTxLFj6VDEsWPpUMSxY+lQRBpFPF7EsWPpUMSxY+lQxLFj6VDEsWPpUMSxYzleROgvd3NTxLFj6VDEsWPpUMSxY+lQRBpFPF7EsWPpUMSxY+lQxA47lmk634rY9IuLXP9deqXXl34xU5HMNCAzPb6/rp+ZeLKZkq5min6ppMu7TnKb+U5OfWenvsmp74Lru1y++Us4zHyzU9+C67teLpWWZr6rU98nr2ycr+0Kle/N1IBkJiKZSUhmTl6DOKarGT7wWd7jO5nu4rs49c1OfQuub23trNWp74brW1s7W3DqOwJtIFtCMpORzBCSGeB9kPZZ3oD3Qapv4H2Q6ht4H6T6bi73yzkEp76Bzw2VtTMH4HND1XfG2UDmQEhmCpIZRjIDvA9SPstzAN4Hqb6B90Ga7wi8D1J9R5f75RyTU9/A54ba2tnj2wzu4rvgbCBzZCQzQKRDjkCkQ47A+yDtszwB74NU3z75iZx88hM5AfMT2trZIzL8Lr6Bzw21tTMBnxuqvgVoA5kqkhkg0iFnINIhZ+B9kPZZnoH3Qapvn/xE7hECexffwPyEtnZmYH5C9Q18bqitnRn43FD1DUSnZwKi0zMBkQ6ZgEiHTD458twj1u8uvn3yE5l88hOZgPkJbe0kYH5C9Q18bqitnQX43FD1DUSn5wJEp+eCRDr0yHTqZ8YnR56LT448F6f8RHHKTxRgfkJbOxmYn1B9A58bamsnA58bqr6B6PTcI/ujnxkk0oGRSAf2yZFn9smRZ3bKT4hTfgI5f0JbO5HzJ1TfwOeG2tqJnD+h+kai0wWJThck0kGQSAdxypFXpxx5dcpPVKf8BHL+hLZ2IudPqL6Bzw21tRM5f0L1jUSnVyQ6vSKRDg2JdGhOOfLmlCNvTvmJ00Mlevn2mcOXkfMnVN8+c/gycv6E6huITqcARKdTACIdKACRDhR8cuQUyKlvn/wEBZ/8BCHnTyhrJyHnT6i+febwEXL+hOobiE6nCESnUwQiHejs+AfdjE+OnKJPjpyiT36Cok9+gpDzJ7S1Ezl/QvXtM4ePkPMnVN9AdDqdHSqhmwEiHSgBkQ6UfHLklHxy5JR88hOUffIThJw/oa2dyPkTqm+fOXyEnD+h+gai0ykD0emUgUgHykCkA2WfHDmRT46cyCc/QeSTnyDk/Alt7UTOn1B9+8zhI+T8CdU3EJ1OBESnEyGRDgWJdCg+OXIqPjlyKk75idNDJXr59pnDR8j5E6pvnzl8hJw/ofoGotOJgeh0YiTSgZFIB/bJkdPp8Q+9fDvlJ9gpP4GcP6Gtncj5E6pvnzl8hJw/ofpGotMFiU4XJNLh7PgH3YxTjlyccuTilJ8Qp/wEcv6EtnYi50+ovn3m8BFy/oTqG4lOPztUQjeDRDpUJNKhOuXIq1OOvDrlJ5pTfgI5f0JbO5HzJ1TfPnP4CDl/QvWNRKc3JDq9IZEODYl0aD458hJ8cuQl+OQnSvDJTxTk/All7SyBnPr2mcNXkPMnVN9AdHoJQHR6CUCkQ4lApEOJPjnyEn1y5CX65CfK6aESvXz7zOEryPkTqm+fOXwFOX9C9Q1Ep5cERKeXBEQ6lAREOpTkkyMvp8c/9PLtk58oySc/UZDzJ7S1Ezl/QvXtM4evIOdPqL6B6PSSgej0koFIh3J2/INuxidHXrJPjrxkn/xEyT75iYKcP6Gtncj5E6pvnzl8BTl/QvUNRKeXs0MldDNApEMhINKhkE+OvJBPjryQU36iOOUnkPMntLUTOX9C9e0zh68g50+ovoHo9FKA6PRSkEiHgkQ6FJ8ceWGfHHlhp/wEO+UnkPMntLUTOX9C9e0zh68g50+ovoHo9MJAdHphJNJBkEgHccqRi1OOXJzyE6eHSvTy7TOHryDnT6i+febwFeT8CdU3Ep1ekej0ikQ6VCTSoTrlyE+Pf+jl2yk/UZ3yE8j5E9raiZw/ofr2mcNXkPMnVN9IdHpDotMbEulwdvyDbsYpR96ccuTNKT/RnPITyPkTytrJyPkTqm+fOXyMnD+h+gai0zkQkhkg0oEDEOnAwSdHzsEnR87BJz/B0Sc/wcj5E9raiZw/ofr2mcPHyPkTqm8gOp0jEJ3OEYh04AhEOnD0yZFz8smRc/LJT3DyyU8wcv6EtnYi50+ovn3m8DFy/oTqG4hO5wREp3MCIh04A5EOnH1y5Jx9cuScffITfHqoRC/fPnP4GDl/QvXtM4ePkfMnVN9AdDoTEJ3OBEQ6MAGRDkw+OXI+Pf6hl2+f/ASTT36CkfMntLUTOX9C9e0zh4+R8ydU30B0OhcgOp0LEulwdvyDbsYnR87FJ0fOxSk/UZzyE8j5E9raiZw/ofr2mcPHyPkTqm8gOp3PDpXQzSCRDoxEOrBPjpzZJ0fO7JSfEKf8BHL+hLZ2IudPqL595vAxcv6E6huJThckOl2QSAdBIh3EKUdenXLk1Sk/UZ3yE8j5E9raiZw/ofr2mcPHyPkTqm8kOr0i0ekViXRoSKRDc8qRN6cceXPKT5weKtHLt88cPkbOn1B9+8zhY+T8CdU3EJ0uAYhOlwBEOkgAIh0k+OTIJZBT3z75CQk++QlBzp9Q1k5Bzp9QffvM4RPk/AnVNxCdLhGITpcIRDrI2fEPuhmfHLlEnxy5RJ/8hESf/IQg509oaydy/oTq22cOnyDnT6i+geh0OTtUQjcDRDpIAiIdJPnkyCX55Mgl+eQnJPvkJwQ5f0JbO5HzJ1TfPnP4BDl/QvUNRKdLBqLTJQORDpKBSAfJPjlyIZ8cuZBPfkLIJz8hyPkT2tqJnD+h+vaZwyfI+ROqbyA6XQiIThdCIh0KEulQfHLkUnxy5FKc8hOnh0r08u0zh0+Q8ydU3z5z+AQ5f0L1DUSnCwPR6cJIpAMjkQ7skyOX0+Mfevl2yk+wU34COX9CWzuR8ydU3z5z+AQ5f0L1jUSnCxKdLkikw9nxD7oZpxy5OOXIxSk/IU75CeT8CW3tRM6fUH37zOET5PwJ1TcSnX52qIRuBol0qEikQ3XKkVenHHl1yk80p/wEcv6EtnYi50+ovn3m8Aly/oTqG4lOb0h0ekMiHRoS6dB8cuQ1+OTIa/DJT9Tgk5+oyPkTytpZAzn17TOHryLnT6i+gej0GoDo9BqASIcagUiHGn1y5DX65Mhr9MlP1NNDJXr59pnDV5HzJ1TfPnP4KnL+hOobiE6vCYhOrwmIdKgJiHSoySdHXk+Pf+jl2yc/UZNPfqIi509oaydy/oTq22cOX0XOn1B9A9HpNQPR6TUDkQ717PgH3YxPjrxmnxx5zT75iZp98hMVOX9CWzuR8ydU3z5z+Cpy/oTqG4hOr2eHSuhmgEiHSkCkQyWfHHklnxx5Jaf8RHHKTyDnT2hrJ3L+hOrbZw5fRc6fUH0D0em1ANHptSCRDgWJdCg+OfLKPjnyyk75CXbKTyDnT2hrJ3L+hOrbZw5fRc6fUH0D0emVgej0ykikgyCRDuKUIxenHLk45SdOD5Xo5dtnDl9Fzp9QffvM4avI+ROqbyQ6vSLR6RWJdKhIpEN1ypGfHv/Qy7dTfqI65SeQ8ye0tRM5f0L17TOHryLnT6i+kej0hkSnNyTS4ez4B92MU468OeXIm1N+ojnlJ5DzJ5S1syHnT6i+febwNeT8CdU3EJ3eAiGZASIdWgAiHVrwyZG34JMjb8EnP9GiT36iIedPaGsncv6E6ttnDl9Dzp9QfQPR6S0C0ektApEOLQKRDi365Mhb8smRt+STn2jJJz/RkPMntLUTOX9C9e0zh68h50+ovoHo9JaA6PSWgEiHloFIh5Z9cuQt++TIW/bJT7TTQyV6+faZw9eQ8ydU3z5z+Bpy/oTqG4hObwREpzcCIh0aAZEOjXxy5O30+Idevn3yE4188hMNOX9CWzuR8ydU3z5z+Bpy/oTqG4hObwWITm8FiXQ4O/5BN+OTI2/FJ0feilN+ojjlJ5DzJ7S1Ezl/QvXtM4evIedPqL6B6PR2dqiEbgaJdGAk0oF9cuSNfXLkjZ3yE+KUn0DOn9DWTuT8CdW3zxy+hpw/ofpGotMFiU4XJNJBkEgHccqRV6cceXXKT1Sn/ARy/oS2diLnT6i+febwNeT8CdU3Ep1ekej0ikQ6NCTSoTnlyJtTjrw55SdOD5Xo5dtnDl9Dzp9QffvM4WvI+ROqbyA6PYYAhKdPboBYh8kNEOwwufHJkk/GyatxnxTFZNwnRjEZ95nHNxn3Gcg3GfeZyBcDchSFbhyIVJ/cAKHqkxsg7mFyQ1BufHLlk3GfYPlk3CdRMRn3iVRMxn1m88WAHEqhG/eZzjcZ9xnPNxkHotYnNwTlBoiBmNwAQRCTG5+M+WTcJ2Q+GfdJV8SQfeIVk3GfOX2TcZ9BfZNxn0l9k3HyanxzjatB5io2qcSkqiZVs6i2QwQWVdGkSiZVNqnIpDLNDTLNDTLNDTLNDTLNjWKaG8U0N4ppbhTT3CimuVFMc6OY5kYxzY1imhvFNDfYNDfYNDfYNDfYNDfYNDfYNDfYNDfYNDfYNDfYNDfENDfENDfENDfENDfENDfENDfENDfENDfENDfENDeqaW5U09yoprlRTXOjmuZGNc2Napob1TQ3qmluVNPcaKa50Uxzo5nmRjPNjWaaG800N5ppbjTT3GimubHCX9UUrqryzT55vsFr5fIKrdbrpal9/uf0y4+/vv/w4f1//vXh008//P7+08ffXoTh5f8tfx4U4evJsnC+vTK9+F3+NNjQkEFTDBo2aMSgqQZN269Zfv9vaKJBY5gHzTAPmmEeNMM8aIZ50AzzoBnmQTPMg7gMRZYq9SJqIcxE0SJKFlG2iGhTFMtMtFy9dj3ELa3MqreMlHAKFxGnPBdli4gsomIQLT9tZBK+Hgq2OhNli4gsomIRLb5tuQS5iEpqM5FYRNUiagbR8pOPb0SZZqLlkpdyE8ns/bR8jLslYotILKJqENFK9dp1GnGYfUZQsYgW7cn0cPxycj6dk38vWj7ZY6ZwfSWKM1GyiLJFtDy4cm0WWXg295ZPv7hdn0xICLNPo+XDry1RNJR8+ehrS5QtIrKIikXEFpFYRJZZvnzmtSFaPvLaEllmhFhmhFhmhKy8n+r1I0zabAFYPoHaElWLqBlEy8dPW6JoESWLKFtEtCWq80+j5f3mlogtIrGIlmdEzeUqKrPlc3mPxlXyVVR5JiKLqFhEbBEtV69yu4lkJqoWUdsvSss7tS1RtIiSRZQtouVxauk691rimUg2WgJu9ZtP2PmpVqTp/75ePf00m98phg6vka4d6PSzzG5+ZXc2nbOttzYp8v5+KEWxiKpFZOjxUgoWUdwrmn6JL5cuN0UvlMDloOTlKf73U2K5K9pUVZOqWVTLjdGmKppUyaTKJhWZVIvvrmkTki9vr+ln/n5ns9yIbarEpKomVVtRSbip6veq5WZsU7VceZ4e3F1UPD25/vxXztenK1O9qej7Hni54dlUiUlVTaq2oqrlpmrff8wvn7RvqqJJlUyqbFKRSVVMqrW50dpVNS3Zn//KufumqppUa3Pj9v6aVHGjY5jW3OuLTKti22owbq3C9PP81DMERFMR0VRCNJURTRGiqYJoihFNyV1MSXtlanaqEmonU/FmKsqxHWCM8R6m9C3jyvPGe5vKiKYI0VRBNMWAptLau6+86hN5Lks2WbbJyCYrNhnbZGKTVZusmWQ52GS2WZJtsySvzJKU+fZGKbNj5Uw2WbHJ2CYTm2xluDPdPjvyHDqiYJOtVDLzzWSWWc9DK/dW4m1HV/JffG6/LWsmWQk2WbTJkk2WbTKyyYpNtvIOKCw3mcya0LI2S15NrvL63zgurWvcwvXftbdXi2CsCxfXRPT14po4vb74i6GKZqiBGeKAZiiiGUpohjKaIUIztPIu43g7c58Op7//+Fp5IMN8zXKZfp5/6q08W+FpHb3JKM1kxSZb+Whmfm1ytoCvPF5hCbd+TdIMUlt5vrIpaybZyhOWTVm0yZJNlm2ylVki9EpWZnNy7UHQloxtMrHJ1mZJfi2bdRlrD4M2ZGtPg7Zk0SZLNlm2ycgmW5slt0PD6TNh9qGw9kxoSyY2WbXJ1mYJv5Z9/6mc1h7cbMmiTZZssmyTkU1WbLKVWVJfraY1pZlMbLJqkzWTLK7Mkhpey+aITrTJkk2WbTKyyYpNxjbZyizhemtn6rf/BmPhKDRLujZNWfIMd4u1z6tQu70KH+Xj1s5n/15TG0Dd2gnpXlNcb6YWXkX63/rCq9RTXqWd8Sprp7udX6XTlGzXM8hcv2WbDO+TtcPfv9fUxvsk9xn1Gm7jUeP3vU+i0P/WF14lnvIq6ZRXyae8Sp8pWa8JntPPdPBpeyK5h6mN90npM+q1vBqPMmtRS+5/6wuvQqe8SjnlVfiUVxHLiVpaO7bfkjWTbO0IfEsWbbJkk2WbjGyyYpOxTWabJWybJWybJWuHw/qD07SC63O+0V9MIc5kZJMVm4xtMrHJqk3WTLK1M+UtWbTJkk1mmyXVNkuqYZZMv6SXi1cw3/WIo1UIV5fQfknZL+H9Etkvqfslbbdk+SRLl8T9kv2jH/ePftw/+nH/6Mf9ox/3j37cP/px/+in/aOf9o9+2j/6af/op/2jn/aPfto/+mn/6Kf9o5/2j37eP/p5/+jn/aOf949+3j/6ef/o5/2jn/ePft4/+nn/6NP+0af9o0/7R5/2jz7tH33aP/q0f/Rp/+jT/tGn/aNf9o9+2T/6Zf/ol/2jX/aPftk/+mX/6Jf9o1/2j37ZP/q8f/R5/+jz/tHn/aPP+0ef948+7x993j/6vH/0ef/oy/7Rl/2jL/tHX/aPvuwffdk/+rJ/9GX/6Mv+0Zf9o1/3j37dP/p1/+gvn2bU6zfi1FexABcJ7ZeU/RLeJ/k8/fa/P/z6/ocfP7x7yWV++Y9/fPzpEtM8/fr7//1y+S+XIOdffv3007uf//j13Uuk8y3N+WWwpqeGb6fj5snKS4VY3oq82PrynxK9nR4lv/wav1yZ36ZcrnkrL5fkwG9zkq/q6YHIl7/0X3Wtb1PLV3Wb/ljj66HNy/XT2U5rl+vjdH2crv/8ebrJ/wc=","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"61":{"source":"use sha256;\n\nfn u32_to_le_bytes(value: u32) -> [u8; 4] {\n    let mut res = [0; 4];\n    for i in 0..4 {\n        res[i] = (value >> (i * 8)) as u8;\n    }\n\n    res\n}\n\nfn sha256_to_le_bytes(value: str<64>) -> [u8; 32] {\n    let mut res = [0; 32];\n    let value = value.as_bytes();\n    for i in 0..32 {\n        res[31 - i] =\n            (hex_symbol_to_byte(value[2 * i]) << 4) + hex_symbol_to_byte(value[2 * i + 1]);\n    }\n\n    res\n}\n\nfn bytes_to_hex_string(value: [u8; 32]) -> str<64> {\n    let mut res = [0; 64];\n    for i in 0..32 {\n        res[2 * i] = byte_to_hex_symbol(value[i] >> 4);\n        res[2 * i + 1] = byte_to_hex_symbol(value[i] & 0xf);\n    }\n\n    str<64>::from(res)\n}\n\nfn byte_to_hex_symbol(value: u8) -> u8 {\n    if value <= 9 {\n        value + 48\n    } else {\n        value + 87\n    }\n}\n\nfn hex_symbol_to_byte(value: u8) -> u8 {\n    if value < 58 {\n        value - 48\n    } else {\n        value - 87\n    }\n}\n\nfn reverse_bytes(bytes: [u8; 32]) -> [u8; 32] {\n    let mut res = [0; 32];\n    for i in 0..32 {\n        res[i] = bytes[31 - i];\n    }\n    res\n}\n\nstruct Block {\n    version: u32,\n    prev_block: str<64>,\n    merkle_root: str<64>,\n    timestamp: u32,\n    bits: u32,\n    nonce: u32,\n}\n\nimpl Block {\n    fn to_byte_array(self) -> [u8; 80] {\n        let mut res = [0; 80];\n        let mut count = 0;\n\n        let vers = u32_to_le_bytes(self.version);\n        for i in 0..4 {\n            res[count] = vers[i];\n            count += 1;\n        }\n\n        let prev = sha256_to_le_bytes(self.prev_block);\n        for i in 0..32 {\n            res[count] = prev[i];\n            count += 1;\n        }\n\n        let merkle = sha256_to_le_bytes(self.merkle_root);\n        for i in 0..32 {\n            res[count] = merkle[i];\n            count += 1;\n        }\n\n        let time = u32_to_le_bytes(self.timestamp);\n        for i in 0..4 {\n            res[count] = time[i];\n            count += 1;\n        }\n\n        let bits = u32_to_le_bytes(self.bits);\n        for i in 0..4 {\n            res[count] = bits[i];\n            count += 1;\n        }\n\n        let nonce = u32_to_le_bytes(self.nonce);\n        for i in 0..4 {\n            res[count] = nonce[i];\n            count += 1;\n        }\n\n        res\n    }\n}\n\nfn get_block_hash(value: Block) -> str<64> {\n    bytes_to_hex_string(\n        reverse_bytes(sha256::digest(sha256::digest(value.to_byte_array()))),\n    )\n}\n\nfn main() {\n    let block = Block {\n        version: 1,\n        prev_block: \"00000000b873e79784647a6c82962c70d228557d24a747ea4d1b8bbe878e1206\",\n        merkle_root: \"20222eb90f5895556926c112bb5aa0df4ab5abc3107e21a6950aec3b2e3541e2\",\n        timestamp: 1296688946,\n        bits: 486604799,\n        nonce: 875942400,\n    };\n\n    assert(\n        get_block_hash(block) == \"000000006c02c8ea6e4ff69651f7fcde348fb9d557a06e6957b65552002a7820\",\n    );\n    println(get_block_hash(block));\n}\n","path":"/home/dmitrii/zk/wrapless-noir-prover/blocks/src/main.nr"},"64":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n","path":"/home/dmitrii/nargo/github.com/noir-lang/sha256/v0.1.0/src/sha256.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","print_unconstrained","directive_to_radix","directive_integer_quotient"]}