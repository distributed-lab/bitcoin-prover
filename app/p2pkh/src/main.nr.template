use sign::{{transaction::Transaction, address::Address}};
use bvm::{{stack::Stack, utils::empty_stack_array}};
use utils::convert::{{le_bytes_to_u32, hex_to_bytes}};
use script::script::check_p2pkh_template;

global CUR_TX_LEN: u32 = {curTxLen};
global PREV_TX_LEN: u32 = {prevTxLen};
global SIG_LEN: u32 = {signLen};
global PK_LEN: u32 = {pkLen};

fn main(cur_tx_data: str<CUR_TX_LEN>, prev_tx_data: str<PREV_TX_LEN>, signature: str<SIG_LEN>, pub_key: str<PK_LEN>, input_to_sign: pub u32) -> pub bool {{
    let mut res = true;

    let cur_tx_data = hex_to_bytes(cur_tx_data);
    let prev_tx_data = hex_to_bytes(prev_tx_data);

    let cur_tx = Transaction::<CUR_TX_LEN / 2, {curTx.inputCount}, {curTx.inputCountLen}, {curTx.inputSize}, {curTx.outputCount}, {curTx.outputCountLen}, {curTx.outputSize}, {curTx.maxWitnessStackSize}, {curTx.witnessSize}>::new(cur_tx_data, false);
    let prev_tx = Transaction::<PREV_TX_LEN / 2, {prevTx.inputCount}, {prevTx.inputCountLen}, {prevTx.inputSize}, {prevTx.outputCount}, {prevTx.outputCountLen}, {prevTx.outputSize}, {prevTx.maxWitnessStackSize}, {prevTx.witnessSize}>::new(prev_tx_data, false);
    let mut stack = Stack::new(cur_tx, prev_tx, empty_stack_array::<80, 7>());
    let mut script_pub_key = [0; 26];

    let vout_pos = cur_tx.inputs[input_to_sign].vout.offset;
    let mut vout_bytes = [0; 4];

    for i in 0..4 {{
        vout_bytes[i] = cur_tx.data[vout_pos + i];
    }}

    let vout = le_bytes_to_u32(vout_bytes);
    let script_pub_key_pos = prev_tx.outputs[vout].script_pub_key.offset;

    script_pub_key[0] = 25;
    for i in 0..25 {{
        script_pub_key[i + 1] = prev_tx.data[script_pub_key_pos + i];
    }}

    assert(check_p2pkh_template(script_pub_key));

    let addr = Address::new_p2pkh();

    stack.op_pushbytes(hex_to_bytes(signature));
    stack.op_pushbytes(hex_to_bytes(pub_key));
    stack.op_dup();
    stack.op_hash160::<PK_LEN / 2>();

    let mut hash_pub_key = [0; 20];
    for i in 0..20 {{
        hash_pub_key[i] = script_pub_key[i + 4];
    }}

    stack.op_pushbytes(hash_pub_key);
    stack.op_equal();
    
    if !stack.verify() {{
        println("Failed pk hash");
        res = false;
    }}
                   
    if !stack.op_checksig_sighash_all::<SIG_LEN / 2, 26, PK_LEN / 2>(input_to_sign, vout, addr) {{
        println("Failed signature");
        res = false;
    }}

    res
}}