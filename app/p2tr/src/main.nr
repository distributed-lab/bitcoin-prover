use dep::bignum::{BigNum, U768};
use crypto::point::Point;
use crypto::types::{I768, sqrt_secp256k};
use p2tr_lib::keys::get_tweaked_pub_key;
use p2tr_lib::merkle_root::{get_branch, hash_from_script};
use std::ops::{Add, Mul};
use utils::{convert::hex_to_bytes, encode::encode_bech32m};

global N: u32 = 4;

fn main(address: pub str<62>, pub_key: str<64>, script: str<N>) -> pub bool {
    let mut node: [u8; 32] = hash_from_script(script);

    let modulo: U768 = U768::from_be_bytes([
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x2F,
    ]);

    let pub_x = I768 {
        num: U768::from_be_bytes(
            [0; 65].as_slice().append(hex_to_bytes(pub_key)).as_array::<97>(),
        ),
        is_neg: false,
    };

    // y^2 = x^3 + 7
    let pub_y = sqrt_secp256k(pub_x.mul(pub_x).umod(modulo).mul(pub_x).add(I768::from(7)).umod(
        modulo,
    ));

    let pub_key_point = Point { x: pub_x, y: pub_y, is_O: false };

    let twpk = get_tweaked_pub_key(pub_key_point, node);

    encode_bech32m(twpk.to_be_bytes().as_slice().pop_front().1.as_array()) == address
}
