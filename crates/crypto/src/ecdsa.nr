use super::{point::{get_low_s_if_needed, inv_mod, mul_point, get_y_from_x}, types::I768};
use dep::bignum::{BigNum, U256, U768};
use std::ecdsa_secp256k1;
use utils::{
    convert::get_256_bits_from_768,
    decode::decode_der,
};

pub fn ecdsa_sign(message: [u8; 32], priv_key: U256, nonce: U256) -> (U256, U256) {
    let modulo_p = U768::from_be_bytes([
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x2F,
    ]);

    let modulo_n = U768::from_be_bytes([
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B, 0xBF,
        0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41,
    ]);

    let message_num = I768 {
        num: U768::from_be_bytes([0; 65].as_slice().append(message).as_array::<97>()),
        is_neg: false,
    };
    let priv_key = I768 {
        num: U768::from_be_bytes([0; 64].as_slice().append(priv_key.to_be_bytes()).as_array::<97>()),
        is_neg: false,
    };
    let rand_point = mul_point(nonce, modulo_p);

    let nonce = I768 {
        num: U768::from_be_bytes(
            [0; 64].as_slice().append(nonce.to_be_bytes()).as_array::<97>(),
        ),
        is_neg: false,
    };

    // Safety: num * num^-1 = 1 modulo
    let inv_nonce = unsafe { inv_mod(nonce, modulo_n) };
    assert((inv_nonce * nonce).umod(modulo_n).num == U768::from(1));

    let r = rand_point.x.umod(modulo_n);
    let mut s = (inv_nonce * (message_num + r * priv_key).umod(modulo_n)).umod(modulo_n);

    if s.num > (modulo_n.udiv(U768::from(2))) {
        s.num = modulo_n - s.num;
    }

    (get_256_bits_from_768(r.num), get_256_bits_from_768(s.num))
}

fn get_xy_from_pubkey<let PUBKEY_LEN: u32>(pubkey: [u8; PUBKEY_LEN]) -> ([u8; 32], [u8; 32]) {
    let mut pub_x = [0; 32];
    let mut pub_y = [0; 32];

    if PUBKEY_LEN == 33 {
        if (pubkey[0] != 0x02) & (pubkey[0] != 0x03)  {
            assert(false, "Invalid pubkey");
        }
        pub_y = get_y_from_x(pubkey.as_slice().as_array());
        pub_x = pubkey.as_slice().pop_front().1.as_array::<32>();
    } else if PUBKEY_LEN == 65 {
        if pubkey[0] != 0x04 {
            assert(false, "Invalid pubkey");
        }
        for i in 0..32 {
            pub_x[i] = pubkey[i + 1];
        }
        for i in 0..32 {
            pub_y[i] = pubkey[i + 33];
        }
    } else {
        assert(false, "Invalid pubkey length");
    }

    (pub_x, pub_y)
}

pub fn ecdsa_verify<
    let DER_SIGNATURE_LEN: u32,
    let PUBKEY_LEN: u32,
>(
    der_encoded_signature: [u8; DER_SIGNATURE_LEN],
    pubkey: [u8; PUBKEY_LEN],
    message_hash: [u8; 32],
) -> bool {
    let (pub_x, pub_y) = get_xy_from_pubkey(pubkey);

    let (sign_r, sign_s) = decode_der(der_encoded_signature);
    let sign_s = get_low_s_if_needed(sign_s);

    let sign_r = sign_r.to_be_bytes().as_slice().pop_front().1.as_array::<32>();
    let sign_s = sign_s.to_be_bytes().as_slice().pop_front().1.as_array::<32>();

    let signature = sign_r.as_slice().append(sign_s).as_array::<64>();

    ecdsa_secp256k1::verify_signature(
        pub_x,
        pub_y,
        signature,
        message_hash,
    )
}

#[test]
fn ecdsa_sign_test() {
    let message = [
        0x47, 0xB2, 0x08, 0x90, 0x89, 0xBB, 0x28, 0x5F, 0xF0, 0xD7, 0xE6, 0x7D, 0x6F, 0xE4, 0xC2,
        0x77, 0x9D, 0x22, 0x6F, 0xD4, 0x0F, 0x81, 0x5B, 0x50, 0xFB, 0x91, 0xB9, 0xB3, 0xAF, 0xAA,
        0x80, 0xFD,
    ];

    let nonce = U256::from_be_bytes([
        0x00, 0x2A, 0xBE, 0x2F, 0x9F, 0xA6, 0x97, 0x1E, 0x62, 0x1E, 0xFC, 0x3D, 0xD6, 0x18, 0x61,
        0x79, 0x10, 0x76, 0xDB, 0x3B, 0x3F, 0xFC, 0x5A, 0x8F, 0xF1, 0xCA, 0xD9, 0x13, 0x8D, 0xBD,
        0xE9, 0x83, 0x1A,
    ]);

    let priv_key = U256::from_be_bytes([
        0x00, 0x74, 0x52, 0xC2, 0x07, 0x1E, 0x16, 0x3E, 0x22, 0x60, 0x75, 0x4A, 0xA9, 0x8E, 0xFA,
        0x90, 0x69, 0x71, 0xCC, 0x56, 0xDD, 0x6A, 0xD8, 0x96, 0x72, 0xDC, 0x5B, 0x4C, 0x49, 0x6D,
        0x4A, 0x15, 0x9E,
    ]);

    let pub_key_x = [
        0x8F, 0x31, 0xFF, 0x53, 0x65, 0xD9, 0xF8, 0x4F, 0xFE, 0x81, 0x3C, 0xA3, 0xD4, 0x30, 0xCC,
        0x41, 0xDE, 0x82, 0x31, 0x7D, 0xB7, 0x49, 0x0B, 0x61, 0xF3, 0x6E, 0x51, 0x88, 0xE7, 0xF5,
        0xBF, 0x13,
    ];

    let pub_key_y = [
        0xC6, 0x35, 0xD3, 0x73, 0x23, 0x6B, 0x57, 0x74, 0x62, 0x90, 0xB9, 0x9F, 0xDC, 0x80, 0xDB,
        0x65, 0xBB, 0x77, 0x72, 0x39, 0x7C, 0x0D, 0x16, 0xC7, 0xFA, 0x5F, 0xD4, 0x48, 0x4B, 0xDE,
        0xF7, 0x72,
    ];

    let (r, s) = ecdsa_sign(message, priv_key, nonce);

    let signature = r.to_be_bytes().as_slice().append(s.to_be_bytes()).as_array::<64>();

    assert(ecdsa_secp256k1::verify_signature(
        pub_key_x,
        pub_key_y,
        signature,
        message,
    ));
}
